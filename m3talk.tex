% !TEX encoding = UTF-8 Unicode

\documentclass[ 
% amsmath=
% amsthm=
% array=
% calc
% enumerate=
% extsizes
% geometry
% hyperref
xcolor={usenames,dvipsnames,svgnames,tablem} 
%,bigger
,handout
]{beamer}
% automatically loaded: xcolor, amsmath, amsthm, calc, geometry, hyperref, extsizes

\input{HEADER/HEADER}
% ********************************

\author{Alexander Maringele}
\title{Term-Indexing
%\\and\\First Order Theorem Proving
}
\subtitle{for Instantiation-Based\\First Order Theorem Proving}
\date{January 27th, 2016}
%======

\begin{document}

\selectlanguage{english}

%\Cloud

% === TITLE ===
\frame[<+->]{
\maketitle
}

% === REFERENCES ===
\section*{References}
\frame[<+->]{
\frametitle{References}

\nocite{SRV2001ti,RV2003eir}	% ZHM2009jar
\bibliographystyle{amsalpha}
\bibliography{biblio}

}

% === OVERVIEW ===

\section*{Outline}
\setcounter{tocdepth}{1}
\frame[<+->]{
\frametitle{Outline}
	\tableofcontents
}



%====================================================================
% BEGIN: CONTENT ----------------------------------------------------
%====================================================================

%\input{xy}

\section{Motivation}
\subsection{Notion}

\subsection{First Order Clause Logic}

\begin{frame}

\begin{notation}[First Order]
\begin{enumerate}
\item $\Sigma = (\SIGV, \SIGF, \SIGP)$ \hfill signature
%\item $P \in \Sigma_\mP = \{ \mA, \mB, \ldots \}$ \hfill predicate symbols 
%\item $F \in \Sigma_\mf = \{ \mc, \mf,\mg,\ldots \}$ \hfill (constant) function symbols
%\item $V = \{ x,y,z, \ldots\} $ \hfill variables
%\item $C ::=  \lnot \mid \lor \mid {\colG \land \mid\ \rightarrow}$\hfill connectives
%\item {\colG $Q ::= \forall, \exists$ \hfill quantifiers}
\item $\SIGT = \SIGV \cup \{ f(t_1,\ldots,t_n)\mid f\in\SIGF_{(n)}, t_i \in \SIGT \}$\hfill terms
\item $\SIGA = \{ P ( t_1, \ldots, t_n )\mid P\in\SIGP_{(n)}, t_i \in \SIGT\}
\cup
\{ s \foEQ t \mid s,t\in \SIGT\}$\hfill  atoms
%\item {\colG $F ::= A \mid (\lnot F) 
%	\mid (F \lor F)  \mid (F \land F)  
%	\mid (F \rightarrow F)
%	\mid (\forall F)
%	\mid (\exists F) 
%	$ 
%	\hfill formulas
%	
%	}
\item $\SIGL = \SIGA \cup \{ \lnot A \mid A\in \SIGA \}$\hfill literals
\item $\SIGC = 2^\SIGL$, e.g. $\mf(x)\foEQ\ma \lor \ma\foNEQ\mb$\hfill clauses
\item $\SIGS = 2^\SIGC$, e.g. $\{ \mf(x)\foEQ\ma \lor \ma\foNEQ\mb, \mf(x)\foEQ\mb\}$\hfill clause sets
\end{enumerate}
\[
\{ C_1, \ldots, C_n \} \equiv 
\forall\Var(C_1) C_1 
\land \ldots \land
\forall\Var(C_1) C_n 
\]
%A set of clauses is equivalent to a conjunction of universally quantified disjunctions of literals
%and equivalent to a universally quantified conjunction of variable distinct disjunctions of literals.

%\item $S ::= \{ C,\lots,C \}$\hfill sets of clauses
%\item Formulae $F::=$


\end{notation}
\end{frame}

% === saturation-based theorem provers ===
\subsection{Resolution-based theorem provers}
\frame{
	\frametitle{Resolution-based theorem provers}
	\begin{procedure}	
	\begin{enumerate}
	\item Transform the negation of a conjecture $F$
	
	into a equisatisfiable set of clauses $S$.
	\item Expand $S$ with derived clauses 
	in a sufficient$^{\circ\diamond\star}$ way.
	\item Stop if 
	\begin{enumerate}
	\item a proof for unsatisfiability of $S$ has been found\hfill{\colG F is a theorem}
	\item the set $S$ is saturated, hence satisfiable\hfill{\colG F is not a theorem} 
	\item time's up or space's out\hfill \colG we don't know
	\end{enumerate}
	Otherwise, continue with 2.
	\end{enumerate}
	\end{procedure}
	
	\begin{goal}[]
	Sound$^\circ$, refutational complete$^\diamond$, and effective$^\star$ procedure.
	\end{goal}
}

% === the big picture === 
\begin{frame}

\begin{tikzpicture}[scale = 1, transform shape, draw=black, fill=black, thick, sloped]

	\draw[->, ultra thick] (0,0) -- 
%	node[pos=0, above] {$\lnot F\approx S$} 
	node[pos=0, above] {$F$} 
	node[pos=0.32, below] {\color{colN}$\lnot F \approx\ S$}
	node[pos=1.25] {$S$} 
	(2,0);
		
	% outer rectangle
	\draw[rounded corners=-1.5mm] (1,3) rectangle (8.5,-3);
	% is F a theorem?
	\draw(2.4,2.7) node {\color{colN}Is $F$ a theorem?};
	
	% inner rectangle
	\draw[rounded corners=-1.5mm]  (1.5,-2.25) rectangle (8,2.25); 
	 % is S satisfaible?
	 \draw (2.9,-1.9) node {\color{colN}Is $S$ satisfiable?};
	  
	 \draw[thin,dashed,draw=colO] (2.5,0) ellipse (0.4 and 1.2); 
	 \draw[thin,dashed,draw=colO] (2.6,0) ellipse (0.6 and 1.44); 
	  \draw[thin,dashed,draw=colO] (2.8,0) ellipse (0.9 and 1.73); 
	  \draw[thin,dashed,draw=colO] (3.2,0) ellipse (1.35 and 2.07);
	  
	\draw[dashed, decoration=snake, decorate,draw=colG, thick] (1.4,-1) -- (8.1,-0.6);
	\draw[dashed, decoration=snake, decorate,draw=colG, thick] (1.4, 1) -- (8.1,0.6);
		
	\draw[->, draw=colHi, ultra thick] (6.5,1.8) -- 
	node[pos=0,below] {unsatisfiable}
	node[pos=0.85, above] {theorem} 
	(10,1.8) ;
	
	\draw[->,draw=colNa, ultra thick] (7,0.15) -- 
%	node[pos=0,above] {space out}
	node[pos=0,below] {time out}
	node[pos=0.85, above] {maybe} (10.5,0.15) ;
	
	\draw[->,draw=colLo, ultra thick] (7,-1.3) -- 
	node[pos=0, below] {satisfiable}
	node[pos=0.75, above] {not a theorem} (11,-1.3) ;
\end{tikzpicture}

\end{frame}

% === Example Superpostition ===
%\subsection{Superposition}
%\begin{frame}
%
%\begin{example}[Superposition]
%\vspace{-1em}
%\begin{gather*}
%S = \{ {}^{1:}\mf(\mh(x))\foEQ\mc \lor \mh(\mh(x))\foNEQ \ma, 
%	{}^{2:}\mh(y)\foEQ y, 
%	{}^{3:}\mf(\ma)\foNEQ \mc \}\qquad\\[0.5em]
%\newcommand{\stepA}{
%	\infer[ \alpha % (S_+)\ \{ y\mapsto x \}
%	]{	\mf(x)\foEQ\mc \lor {\colNA\mh(\mh(x))\foNEQ \ma}
%	}{	^{2:}\mh(y)\foEQ y
%		& 
%		^{1:}\mf(\boxed{\mh(x)})\foEQ\mc \lor {\colNA\mh(\mh(x))\foNEQ \ma}
%	}
%}
%\newcommand{\stepB}{
%	\infer[	\beta]
%	{		{\colNA\mh(\mh(\ma))\foNEQ \ma} \lor \mc\foNEQ\mc
%	}{		\stepA & ^{3:}\boxed{\mf(\ma)}\foNEQ \mc
%	}
%}
%\newcommand{\stepC}{
%	\infer[\{\}
%	]{		\mh(\boxed{\mh(\ma)})\foNEQ \ma
%	}{		\stepB
%	}
%}
%\newcommand{\stepD}{
%	\infer[\gamma
%	]{	\boxed{\mh(\ma)}\foNEQ\ma
%	}{	^{2:}\mh(y)\foEQ y\hspace{-3cm} & \stepC
%	}
%}
%\newcommand{\stepE}{
%	\infer[\gamma
%	]{	\ma\foNEQ\ma
%	}{	^{2:}\mh(y)\foEQ y & \stepD
%	}
%}
%\newcommand{\stepF}{
%	\infer[\{\}	%(f)
%	]{	\emptyclause
%	}{	\stepE
%	}
%}
%\stepF
%\end{gather*}
%\center
%$\alpha = \{ y\mapsto x \}$, 
%$\beta=\{ x\mapsto\ma\}$, 
%$\gamma=\{ y\mapsto\ma\}$ 
%\end{example}
%\end{frame}

% === Example Inst-Gen-Eq ===
\subsection{Inst-Gen-Eq}
\begin{frame}
\begin{example}[Inst-Gen-Eq]
%
\vspace{-1em}
%
\newcommand{\inferFXC}{
		\infer[ \sigma]
		{ \mf(x)\foEQ\mc }
		{ ^{2^\ell:}\mh(y)\foEQ y & ^{1^\ell:}\mf(\boxed{\mh(x)})\foEQ\mc} 	
	}
	\newcommand{\inferCnC}{
		\infer[ \tau ]
		{ \emptyclause }
		{ \inferFXC & ^{3^\ell:}\mf(\ma)\foNEQ \mc } 		
	}
%
	\begin{align*}
	S_0 &= \{ ^{1:}\mf(\mh(x))\foEQ\mc \lor \mh(\mh(x))\foNEQ \ma, 
	^{2:}\mh(y)\foEQ y, 
	^{3:}\mf(\ma)\foNEQ \mc \} 
	\\
	S_0\bot &= \{ 
	{\colHI\mf(\mh(\bot))\foEQ\mc} \lor 
	{\colNA\mh(\mh(\bot))\foNEQ \ma}, 
	{\colHI\mh(\bot)\foEQ\bot}, 
	{\colHI\mf(\ma)\foNEQ\mc} 
	\} 
\\
	&
	{\inferCnC
	} 
\\
	S_1 &= \{ \ldots, 
		\mf(\ma)\foNEQ\mc, 
		^{2\sigma\tau:}{\colN\mf(\mh(\ma))\foEQ\mc \lor \mh(\mh(\ma))\foNEQ \ma}, 
		^{3\tau:}{\colN\mh(\ma)\foEQ\ma}
	\} 
\\
	S_1\bot &=
 	\{ \ldots,
		{\colHI\mf(\ma)\foNEQ \mc}, 
 		{\colLO \mf(\mh(\ma))\foEQ\mc
		\lor\mh(\mh(\ma))\foNEQ \ma}, 
		{\colHI\mh(\ma)\foEQ\ma} 
	\} 
	\end{align*}
%
\center
$\sigma=\{ y\mapsto x \}$, $\tau=\{ x\mapsto \ma \}$
\end{example}

%\begin{remark}
%	Superposition [Bachmair, Ganzinger],
%	InstGenEq (Ganzinger, Korovin) are sound and refutational complete with a \EMPH{fair} strategy.
%	\end{remark}
\end{frame}

% === infinite domain ===

%\begin{frame}
%\begin{align*}
%S_1 &= \{ 
%	\mf(x,x)\foNEQ a,
%	\mf(y,\mg(y)) \foEQ a,\\
%	&\qquad\mf(x,y)\foNEQ a \lor \mf (y,z)\foNEQ a \lor \mf(x,z)\foEQ a 
%	\}
%	\\
%%S_1\bot &= \mf(\bot,\bot)\foNEQ a,
%%	\mf(\bot,\mg(\bot)) \foEQ a,
%%	\mf(\bot,\bot)\foNEQ a \lor \mf (\bot,\bot)\foNEQ a \lor f(\bot,\bot)\foEQ a \\
%\end{align*}
%\end{frame}

% === Term retrieval problems ===

\frame{
\frametitle{Term retrieval problems}
\begin{itemize}
\item Find terms that are variants of a given term.
$\vari(\ell,t) \Leftrightarrow \exists\sigma\ \ell\sigma = t$ and $\sigma$ is renaming.
\item Find terms that are unifiable with a given term. 
$\unif(\ell,t) \Leftrightarrow \exists\sigma\ \ell\sigma = t\sigma$
\item Find terms that are instances of a given term.
$\inst(\ell,t) \Leftrightarrow \exists\sigma\ \ell = t\sigma$
\item Find terms that are generalizations of a given term.
$\gene(\ell,t) \Leftrightarrow \exists\sigma\ \ell\sigma = t$
\end{itemize}
\begin{definition}
\end{definition}
}

% === Definition Position ===

\subsection{Position}
\begin{frame}
% p.1860, 2.1 Definition
% 703811, p.26, 2.1.14
\begin{definition}
A position is a sequence of positive integers.
The empty sequence $\varepsilon$ denotes the root position,
$pq$ denotes the concatenation of positions. 
%$p$ and $q$,
%The set of positions is recursively defined: 
%\[
%\pos(t)=\left\{ 
%\begin{array}{ll}
%	\{ \varepsilon \} & \text{if }t\text{ is variable}\\
%	\{ \varepsilon \} \cup \{ ip\mid 1\leq i\leq n \land p \in \pos(t_i) \} & \text{if }t=\mf(t_1,\ldots,t_n)
%\end{array}
%\right.
%\]
%The subterm of $t$ at position $p\in\pos(t)$ is defined:
%\[
%t|_p = \left\{
%\begin{array}{ll}
%	t & \text{if }p=\varepsilon\\
%	t_i|_q & \text{if }t=\mf(t_1,\ldots,t_n) \text{ and } p=iq
%\end{array}
%\right.
%\]
$\Pos(t)$ denotes the set of positions in term $t$, and $t|_p$ denotes the subterm of $t$ at positon $p\in\Pos(t)$.
\end{definition}

\begin{definition}
A postion string is a nonempty string of the form $\langle p_1,s_1\rangle\ldots\langle p_n,s_n\rangle$
where $p_i$ are positions and $s_i$ are function or variable symbols and
\begin{enumerate}
\item
if $p_i$ is a proper prefix of $p_j$ then $i<j$
\item
\end{enumerate}
\end{definition}
\end{frame}

% === ====

\begin{frame}
% 4.1 Position strings, 4.1 Defintion
\begin{definition}

\end{definition}
\end{frame}

% === state machine ====

%\begin{frame}
%\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.1cm,
%                    semithick]
%  \tikzstyle{every state}=[fill=red,draw=none,text=white]
%
%  \node[initial,state] (A)                    {$q_a$};
%  \node[state]         (B) [above right of=A] {$q_b$};
%  \node[state]         (D) [below right of=A] {$q_d$};
%  \node[state]         (C) [below right of=B] {$q_c$};
%  \node[state]         (E) [below of=D]       {$q_e$};
%
%  \path (A) edge              node {0,1,L} (B)
%            edge              node {1,1,R} (C)
%        (B) edge [loop above] node {1,1,L} (B)
%            edge              node {0,1,L} (C)
%        (C) edge              node {0,1,L} (D)
%            edge [bend left]  node {1,0,R} (E)
%        (D) edge [loop below] node {1,1,R} (D)
%            edge              node {0,1,R} (A)
%        (E) edge [bend left]  node {1,0,R} (A);
%\end{tikzpicture}
%
%\href{http://www.texample.net/tikz/examples/state-machine/}{www.texample.net/tikz/examples/state-machine/}
%\end{frame}
\section{path indexing}

\begin{frame}

\begin{gather*}
\left\{\begin{array}{lll}
	\TI{1}\mh(\mf(x,x)), &
	\TI{2}\mh(\mg(\ma,x)), &
	\TI{3}\mh(\mf(y,z)), \\
	\TI{4}\mh(\mg(\ma,y)), &
	\TI{5}\mh(\mf(y,x)), &
	\TI{6}\mh(\mg(y,a))
\end{array}\right\}
\end{gather*}
\begin{center}
\begin{tikzpicture}[->,sloped,above]

\node (root) at (0,2.5) {.};

\node (h) at (1,2.5) {.};

\node (h1) at (2,2.5) {.};

\node (h1f) at (3,4.5) {.};
\node (h1g) at (3,1.5) {.};

\node (h1f1) at (4,5) {.};
\node (h1f2) at (4,4) {.};
\node (h1g1) at (4,2.5) {.};
\node (h1g2) at (4,0.5) {.};

\node (h1f1x) at (6,5) {\{1,3,5\}};
\node (h1f2x) at (6,4) {\{1,3,5\}};
\node (h1g1a) at (6,3) {\{2,4\}};
\node (h1g1x) at (6,2) {\{6\}};
\node (h1g2a) at (6,1) {\{6\}};
\node (h1g2x) at (6,0) {\{2,4\}};

\path (root) edge node {$\mh$} (h)
	(h) edge node {$1$} (h1)
	
	(h1)
		edge node {$\mf$} (h1f)
		edge node {$\mg$} (h1g)
	
	(h1f)
		edge node {$1$} (h1f1)
		edge node {$2$} (h1f2)
	
	(h1g)
		edge node {$1$} (h1g1)
		edge node {$2$} (h1g2)

	(h1f1)
		% edge node {$\ma$} (h1f1a)
		edge node {$*$} (h1f1x)
		
	(h1f2)
%		edge node {$\ma$} (h1f2a)
		edge node {$*$} (h1f2x)
		

	(h1g1)
		edge node {$\ma$} (h1g1a)
		edge node {$*$} (h1g1x)

	(h1g2) 
		edge node {$\ma$} (h1g2a)
		edge node {$*$} (h1g2x)
;
\end{tikzpicture}
\end{center}
$\mh(\mg(y,x)) \mapsto \{ \mh.1.\mg.1.{*}, \mh.1.\mg.2.{*} \}$
\end{frame}

% === ===
\subsection{subterm indexing}
\begin{frame}

\begin{center}
\begin{tikzpicture}[->,sloped,above]

\node (root) at (0,2.5) {$\bullet$};

\node (h) at (1,2.5) {.};

\node (h1) at (2,2.5) {.};

\node (h1f) at (3,4.5) {.};
\node (h1g) at (3,1.5) {.};

\node (h1f1) at (4,5) {.};
\node (h1f2) at (4,4) {.};
\node (h1g1) at (4,2.5) {.};
\node (h1g2) at (4,0.5) {.};

\node (h1f1x) at (6,5) {$\{1,3,5\}$};
\node (h1f2x) at (6,4) {$\{1,3,5\}$};
\node (h1g1a) at (6,3) {$\{2,4\}$};
\node (h1g1x) at (6,2) {$\{6\}$};
\node (h1g2a) at (6,1) {$4\{6\}$};
\node (h1g2x) at (6,0) {$\{2,4\}$};

\node (f) at (0,1) {.};
\node (f1) at (-1,0) {.};
\node (f2) at (1,0) {.};
\node (g) at (0,4) {.};
\node (g1) at (-1,5) {.};
\node (g2) at (1,5) {.};
\node (a) at (-3,2.5) {$\{2^{1.1}, 4^{1.1}, 6^{1.2}\}$};

\path 
	(root) 
		edge node {$\mh$} (h)
		edge node {$\mf$} (f)
		edge node {$\mg$} (g)
		edge node {$\ma$} (a)

	(h) edge node {$1$} (h1)
	
	
	(h1)
		edge node {$\mf$} (h1f)
		edge node {$\mg$} (h1g)
	
	(h1f)
		edge node {$1$} (h1f1)
		edge node {$2$} (h1f2)
	
	(h1g)
		edge node {$1$} (h1g1)
		edge node {$2$} (h1g2)

	(h1f1)
		edge node {$*$} (h1f1x)
		
	(h1f2)
		edge node {$*$} (h1f2x)
		

	(h1g1)
		edge node {$\ma$} (h1g1a)
		edge node {$*$} (h1g1x)

	(h1g2) 
		edge node {$\ma$} (h1g2a)
		edge node {$*$} (h1g2x)
		
%
	(g) 	edge (g1)
		edge (g2)
		
	(f)	edge (f1)
		edge (f2)
;


\path (root) 
	
	
	
;

\end{tikzpicture}
\end{center}
\end{frame}

% === ===

\section{discrimination trees}
\subsection{non-linear terms and perfect filtering}
\begin{frame}

\begin{gather*}
\left\{\begin{array}{lll}
	\TI{1}\mh(\mf(x,x)), &
	\TI{2}\mh(\mg(\ma,x)), &
	\TI{3}\mh(\mf(y,z)), \\
	\TI{4}\mh(\mg(\ma,y)), &
	\TI{5}\mh(\mf(y,x)), &
	\TI{6}\mh(\mg(y,a))
\end{array}\right\}
%%
%		\TI{1}\mh(\mf(x,x)),
%		\TI{2}\mh(\mg(\ma,x)),
%		\TI{3}\mh(\mf(y,z)),
%		\TI{4}\mh(\mg(\ma,y)),
%		\TI{5}\mh(\mf(y,x)),
%		\TI{6}\mh(\mg(y,a))
%%		\\[0.5em]
%
%\ps(t) =
%\begin{cases}
%	* &\text{if $t=x\in\SIGV$} \\
%	\mf.\ps(t_1).\ps(t_2). \cdots.\ps(t_n) &\text{if $t=f(t_1,\ldots,t_n)$}
%	\end{cases}
%
\end{gather*}
%	
\begin{center}
% imperfect filtering	
\begin{tikzpicture}[->,sloped,above]

\node[] (root) at (0,0.5) {.};

\node[] (h) at (0,-0.5) {.};
\node[] (f) at (-1,-1)  {.};
\node[] (g) at (1,-1) {.};

\node[] (fx) at (-1,-2) {.};
\node[] (fxx) at (-1,-3.3) {$\{ 1,3,5 \}$ };

\node[] (ga) at (1.6,-2)  {.};
\node[] (gax) at (1.6,-3.3) {$\{ 2,4 \}$};

\node[] (gx) at (.4,-2) {.};
\node[] (gxa) at (.4,-3.3) {$\{ 6 \}$};

\path (root) edge node {$\mh$} (h)

	(h) edge node {$\mf$} (f) 
	edge node {$\mg$}(g)
	
	(f) edge node {$*$} (fx)
	(fx) edge node {$*$} (fxx)
	
	(g) edge node {$\ma$} (ga)
	edge node {$*$} (gx)
		
	(ga) edge node {$*$} (gax)
	(gx) edge node {$\ma$} (gxa)
	
	;
\end{tikzpicture}
%
\hspace{3em}
%
% perfect filtering
\begin{tikzpicture}[->,sloped,above,node distance=1cm]

\node[] (root) at (0,0.5) {.};

\node[] (h) at (0,-0.5) {.};
\node[] (f) at (-1,-1)  {.};
\node[] (g) at (1,-1) {.};

\node[] (fx) at (-1,-2) {.};
\node[] (fxy) at (-1.6,-3.3) {$\{ 3,5 \}$ };
\node[] (fxx) at (-0.4,-3.3) {$\{ 1 \}$ };

\node[] (ga) at (1.6,-2)  {.};
\node[] (gax) at (1.6,-3.3) {$\{ 2,4 \}$};

\node[] (gx) at (.4,-2) {.};
\node[] (gxa) at (.4,-3.3) {$\{ 6 \}$};

\path (root) edge node {$\mh$} (h)

	(h) edge node {$\mf$} (f) 
	edge node {$\mg$}(g)
	
	(f) edge node {$*_1$} (fx)
	(fx) edge node {$*_1$} (fxx)
	edge node {$*_2$} (fxy)
	
	(g) edge node {$\ma$} (ga)
	edge node {$*_1$} (gx)
		
	(ga) edge node {$*_1$} (gax)
	(gx) edge node {$\ma$} (gxa)
	
	;
\end{tikzpicture}\\[1em]

$\mh(\mf(y,x)) \mapsto \mh.\mf.{*}.{*}$\hspace{6em}$\mh(\mf(y,x)) \mapsto' \mh.\mf.{*_1}.{*_2}$
\end{center}
\end{frame}

%=== example forall ===


\begin{frame}
\begin{tikzpicture}
\node {$\exists $}
% [clockwise from=-170,sibling angle=-160]
child {node {$[a,b,c]$}}
child {node {${\mathsf p}$}
% [clockwise from=-90,sibling angle=0]
 child {node {$a$}}};
     \end{tikzpicture}
     
$(\exists [a,b,c]:({\mathsf p}(a)))$
\end{frame}

\begin{frame}
${\mathsf f}({\mathsf a},x)$

\begin{tikzpicture}
\node {${\mathsf f}$}
child {node {${\mathsf a}$}}
child {node {$x$}};
 \end{tikzpicture}

${\mathsf f}({\mathsf a},x)\approx {\mathsf f}(x,{\mathsf a})$

\begin{tikzpicture}
\node {$\approx $}
% [clockwise from=-150,sibling angle=-120]
child {node at (-0.7,1) {${\mathsf f}$}
 [clockwise from=-130,sibling angle=-80]
 child {node {${\mathsf a}$}}
 child {node {$x$}}}
child {node at (0.7,1){${\mathsf f}$}
 [clockwise from=-130,sibling angle=-80]
 child {node {$x$}}
 child {node {${\mathsf a}$}}};
 \end{tikzpicture}
\end{frame}
 
\end{document}
% ********************************